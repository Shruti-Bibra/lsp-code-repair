# lsp-code-fix

**A structured Python project for automated code analysis, repair, and evaluation using LSP and DSPy.**

---

## Project Description

This project provides tools to:

- Analyze Python code using an LSP (Language Server Protocol).  
- Automatically repair or suggest fixes for code using **DSPyRepair**.  
- Evaluate code correctness and quality using custom scoring metrics and LLM based metrics.  
- Run tests on multiple Python code snippets to assess the repair and evaluation system.

## Architecture

<img width="1288" height="656" alt="image" src="https://github.com/user-attachments/assets/81773d0c-84d6-4d92-86b4-da3f86b2f6d0" />

## Results

Evaluating DSPy Self-Refinement
Once refinement converges, the final generated program is evaluated end-to-end. The
entire pipeline is assessed using the same test cases and category splits that were originally
employed to validate the LSP diagnostics, ensuring a consistent and controlled evaluation
setting. For each test case, a deterministic score is computed for the initial faulty code and
then recomputed for the corrected code produced by DSPy.

- Deterministic Score : 
  The deterministic score aggregates LSP diagnostic outputs by penalizing issues according
  to their severity level: Error (1) = -10 Warning (2) = -5 Info (3) = -1 Hint (4) = 0 where higher
  scores indicate fewer or less severe issues. This scoring function provides a stable and inter-
  pretable metric for quantifying syntactic and static-analysis improvements, enabling direct
  comparison between the original and refined code while avoiding stochastic evaluation
  noise.
  
- LLM as a judge : 
  Beyond LSP-based validation, semantic and logical correctness are evaluated using an LLM-
  as-a-judge framework. The corrected code is generated by DSPy using Gemini 2.5 Flash
  and subsequently assessed by the more powerful Qwen/Qwen3-14B (we used A100 gpu to run
  this), which assigns a score in the range [0, 5] based on: (i) semantic correctness : whether
  the corrected code resolves the issues present in the original program; (ii) preservation of
  the original logic without introducing unnecessary changes; and (iii) overall readability and
  code quality (iv) a concise explanation. Using Qwen3-14B for evaluation provides several
  advantages: it enables a more nuanced assessment of code quality beyond syntax, allows
  identification of subtle logical errors or unnecessary modifications, and ensures that the
  automated repairs maintain the original program intent while producing readable and
  maintainable code suitable for real-world use.


<img width="1314" height="828" alt="image" src="https://github.com/user-attachments/assets/b0ed4ccc-e088-4fe9-959b-35a36bd93c27" />



