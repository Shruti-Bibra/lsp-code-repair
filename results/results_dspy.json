[
    {
        "name": "Correct, complete code",
        "original_code": "import os\n\ndef my_func():\n    return os.getcwd()",
        "dspy_code": "import os\n\ndef my_func():\n    return os.getcwd()",
        "diagnostics": []
    },
    {
        "name": "Code with an undefined variable error",
        "original_code": "def my_func():\n    print(undeclared_variable)",
        "dspy_code": "def my_function():\n    x = \"some_value\"\n    print(x)",
        "diagnostics": [
            {
                "message": "\"undeclared_variable\" is not defined",
                "severity": 1,
                "range": {
                    "start": {
                        "line": 1,
                        "character": 10
                    },
                    "end": {
                        "line": 1,
                        "character": 29
                    }
                }
            }
        ]
    },
    {
        "name": "Incomplete code (open function signature)",
        "original_code": "def my_func(",
        "dspy_code": "{\"answer\": \"def my_func():\\n    pass\"}",
        "diagnostics": [
            {
                "message": "Expected parameter name",
                "severity": 1,
                "range": {
                    "start": {
                        "line": 0,
                        "character": 12
                    },
                    "end": {
                        "line": 0,
                        "character": 12
                    }
                }
            },
            {
                "message": "Position-only parameter separator not allowed as first parameter",
                "severity": 1,
                "range": {
                    "start": {
                        "line": 0,
                        "character": 12
                    },
                    "end": {
                        "line": 0,
                        "character": 12
                    }
                }
            },
            {
                "message": "\"(\" was not closed",
                "severity": 1,
                "range": {
                    "start": {
                        "line": 0,
                        "character": 11
                    },
                    "end": {
                        "line": 0,
                        "character": 12
                    }
                }
            },
            {
                "message": "Expected \":\"",
                "severity": 1,
                "range": {
                    "start": {
                        "line": 0,
                        "character": 12
                    },
                    "end": {
                        "line": 0,
                        "character": 12
                    }
                }
            },
            {
                "message": "Expected expression",
                "severity": 1,
                "range": {
                    "start": {
                        "line": 0,
                        "character": 12
                    },
                    "end": {
                        "line": 0,
                        "character": 12
                    }
                }
            },
            {
                "message": "Statements must be separated by newlines or semicolons",
                "severity": 1,
                "range": {
                    "start": {
                        "line": 0,
                        "character": 12
                    },
                    "end": {
                        "line": 0,
                        "character": 12
                    }
                }
            }
        ]
    },
    {
        "name": "Incomplete code (if statement with no body)",
        "original_code": "def my_func(x):\n    if x > 10:",
        "dspy_code": "def main():\n    name = \"Guest\" # Initialize name with a default value\n    try:\n        name = input(\"What is your name? \")\n    except EOFError:\n        # Handle cases where input is not available (e.g., piped input, non-interactive shell)\n        # If EOFError occurs, 'name' will retain its default value \"Guest\"\n        print(\"No input provided. Using default name 'Guest'.\")\n    print(f\"Hello, {name}!\")\n\nif __name__ == \"__main__\":\n    main()",
        "diagnostics": [
            {
                "message": "Expected indented block",
                "severity": 1,
                "range": {
                    "start": {
                        "line": 1,
                        "character": 14
                    },
                    "end": {
                        "line": 1,
                        "character": 14
                    }
                }
            }
        ]
    },
    {
        "name": "Syntactically valid code with a type error",
        "original_code": "def add(a: int, b: int) -> int:\n    return 'hello'",
        "dspy_code": "def add(a: int, b: int) -> int:\n    return a + b",
        "diagnostics": [
            {
                "message": "Type \"Literal['hello']\" is not assignable to return type \"int\"\n\u00a0\u00a0\"Literal['hello']\" is not assignable to \"int\"",
                "severity": 1,
                "range": {
                    "start": {
                        "line": 1,
                        "character": 11
                    },
                    "end": {
                        "line": 1,
                        "character": 18
                    }
                }
            }
        ]
    },
    {
        "name": "Empty code",
        "original_code": "",
        "dspy_code": "def extract_nested_data(data, key):\n    if key in data:\n        return data[key]\n    for value in data.values():\n        if isinstance(value, dict):\n            result = extract_nested_data(value, key)\n            if result is not None:\n                return result\n    return None\n\nnested_data = {\n    'level1_key': {\n        'level2_key': 'value2',\n        'another_key': {\n            'target_key': 'target_value'\n        }\n    },\n    'some_other_key': 'value1'\n}\n\n# Example usage:\nfound_value = extract_nested_data(nested_data, 'target_key')\nprint(found_value)\n\nfound_value_list = extract_nested_data(nested_data, 'non_existent_key')\nprint(found_value_list)",
        "diagnostics": []
    },
    {
        "name": "Code with only whitespace",
        "original_code": "    \n  ",
        "dspy_code": "",
        "diagnostics": []
    },
    {
        "name": "Code importing a non-existent module",
        "original_code": "import a_module_that_does_not_exist",
        "dspy_code": "{\"answer\": \"\"}",
        "diagnostics": [
            {
                "message": "Import \"a_module_that_does_not_exist\" could not be resolved",
                "severity": 1,
                "range": {
                    "start": {
                        "line": 0,
                        "character": 7
                    },
                    "end": {
                        "line": 0,
                        "character": 35
                    }
                }
            }
        ]
    }
]